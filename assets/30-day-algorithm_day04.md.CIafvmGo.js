import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.DK1-H3E1.js";const o=JSON.parse('{"title":"Day 4 - 链表进阶","description":"","frontmatter":{"order":4},"headers":[],"relativePath":"30-day-algorithm/day04.md","filePath":"30-day-algorithm/day04.md","lastUpdated":1768151371000}'),t={name:"30-day-algorithm/day04.md"};function p(h,s,e,k,d,r){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="day-4-链表进阶" tabindex="-1">Day 4 - 链表进阶 <a class="header-anchor" href="#day-4-链表进阶" aria-label="Permalink to &quot;Day 4 - 链表进阶&quot;">​</a></h1><blockquote><p>📅 日期：2026年1月11日<br> 🎯 主题：链表进阶 + 快慢指针</p></blockquote><h2 id="今日题目" tabindex="-1">今日题目 <a class="header-anchor" href="#今日题目" aria-label="Permalink to &quot;今日题目&quot;">​</a></h2><h3 id="题目1-环形链表-linked-list-cycle" tabindex="-1">题目1：环形链表 (Linked List Cycle) <a class="header-anchor" href="#题目1-环形链表-linked-list-cycle" aria-label="Permalink to &quot;题目1：环形链表 (Linked List Cycle)&quot;">​</a></h3><p><strong>难度</strong>：⭐ 简单</p><p><strong>链接</strong>：<a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noreferrer">LeetCode 141. 环形链表</a></p><h4 id="题目描述" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述" aria-label="Permalink to &quot;题目描述&quot;">​</a></h4><p>给你一个链表的头节点 <code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [3,2,0,-4], pos = 1</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第二个节点。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：head = [1,2], pos = 0</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第一个节点。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：head = [1], pos = -1</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：链表中没有环。</span></span></code></pre></div><h4 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h4><p><strong>方法一：快慢指针（Floyd判圈算法）</strong> ✅ 推荐</p><p>核心思想：</p><ol><li>使用两个指针：<code>slow</code>（慢指针，每次走一步）和 <code>fast</code>（快指针，每次走两步）</li><li>如果链表中有环，快指针最终会追上慢指针</li><li>如果链表中没有环，快指针会先到达链表末尾（<code>null</code>）</li></ol><p><strong>为什么快慢指针能检测环？</strong></p><ul><li>假设环的长度为 <code>C</code>，慢指针进入环时，快指针已经在环中某个位置</li><li>设此时快慢指针之间的距离为 <code>d</code>（0 ≤ d &lt; C）</li><li>每走一步，快指针比慢指针多走一步，距离减少 1</li><li>经过 <code>d</code> 步后，快指针会追上慢指针</li></ul><p><strong>方法二：哈希表</strong></p><p>核心思想：</p><ol><li>遍历链表，将每个节点存入哈希表</li><li>如果遇到已经访问过的节点，说明有环</li><li>如果遍历到 <code>null</code>，说明没有环</li></ol><h4 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><p><strong>方法一：快慢指针（Floyd判圈算法）</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Definition for singly-linked list.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * class ListNode {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     int val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode next;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode(int x) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         val = x;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         next = null;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasCycle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 快指针每次走两步，慢指针每次走一步</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快慢指针相遇，说明有环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快指针到达末尾，说明没有环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>方法二：哈希表</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.HashSet;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.Set;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasCycle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Set&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; visited </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (visited.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curr)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 遇到已访问的节点，说明有环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            visited.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(curr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curr.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 遍历到末尾，说明没有环</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h4><ul><li>时间复杂度： <ul><li>快慢指针：O(n)，最坏情况下需要遍历整个链表</li><li>哈希表：O(n)，需要遍历整个链表</li></ul></li><li>空间复杂度： <ul><li>快慢指针：O(1)，只使用常数额外空间 ✅</li><li>哈希表：O(n)，需要存储所有节点</li></ul></li></ul><hr><h3 id="题目2-删除链表的倒数第-n-个结点-remove-nth-node-from-end-of-list" tabindex="-1">题目2：删除链表的倒数第 N 个结点 (Remove Nth Node From End of List) <a class="header-anchor" href="#题目2-删除链表的倒数第-n-个结点-remove-nth-node-from-end-of-list" aria-label="Permalink to &quot;题目2：删除链表的倒数第 N 个结点 (Remove Nth Node From End of List)&quot;">​</a></h3><p><strong>难度</strong>：⭐⭐ 中等</p><p><strong>链接</strong>：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noreferrer">LeetCode 19. 删除链表的倒数第 N 个结点</a></p><h4 id="题目描述-1" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述-1" aria-label="Permalink to &quot;题目描述&quot;">​</a></h4><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4,5], n = 2</span></span>
<span class="line"><span>输出：[1,2,3,5]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：head = [1], n = 1</span></span>
<span class="line"><span>输出：[]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：head = [1,2], n = 1</span></span>
<span class="line"><span>输出：[1]</span></span></code></pre></div><h4 id="解题思路-1" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路-1" aria-label="Permalink to &quot;解题思路&quot;">​</a></h4><p><strong>方法一：双指针（一次遍历）</strong> ✅ 推荐</p><p>核心思想：</p><ol><li>使用两个指针：<code>first</code>（先走）和 <code>second</code>（后走）</li><li><code>first</code> 先走 <code>n+1</code> 步，然后 <code>first</code> 和 <code>second</code> 同时向前移动</li><li>当 <code>first</code> 到达末尾（<code>null</code>）时，<code>second</code> 指向倒数第 <code>n+1</code> 个节点</li><li>删除 <code>second.next</code>（即倒数第 <code>n</code> 个节点）</li></ol><p><strong>关键点</strong>：</p><ul><li>使用虚拟头节点 <code>dummy</code>，可以统一处理删除头节点的情况</li><li><code>first</code> 先走 <code>n+1</code> 步，这样 <code>second</code> 最终会停在要删除节点的前一个位置</li></ul><p><strong>步骤演示</strong>：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>初始：dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null, n = 2</span></span>
<span class="line"><span>      second  first</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>第1步：first 先走 n+1 = 3 步</span></span>
<span class="line"><span>      dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</span></span>
<span class="line"><span>      second           first</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>第2步：first 和 second 同时移动，直到 first 为 null</span></span>
<span class="line"><span>      dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; null</span></span>
<span class="line"><span>                    second           first</span></span>
<span class="line"><span>      </span></span>
<span class="line"><span>第3步：删除 second.next（即节点 4）</span></span>
<span class="line"><span>      dummy -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 5 -&gt; null</span></span></code></pre></div><p><strong>方法二：两次遍历</strong></p><p>核心思想：</p><ol><li>第一次遍历：计算链表长度 <code>len</code></li><li>第二次遍历：找到第 <code>len - n + 1</code> 个节点（即倒数第 <code>n</code> 个节点）</li><li>删除该节点</li></ol><h4 id="代码实现-1" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现-1" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><p><strong>方法一：双指针（一次遍历）</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Definition for singly-linked list.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * public class ListNode {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     int val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode next;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode() {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode(int val) { this.val = val; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeNthFromEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 创建虚拟头节点，简化边界处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode dummy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dummy.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // first 先走 n+1 步</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // first 和 second 同时移动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode second </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            second </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 删除倒数第 n 个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        second.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second.next.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>方法二：两次遍历</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeNthFromEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 创建虚拟头节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode dummy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dummy.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 第一次遍历：计算链表长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            len</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curr.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 第二次遍历：找到要删除节点的前一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            curr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curr.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 删除节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        curr.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curr.next.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="复杂度分析-1" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析-1" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h4><ul><li>时间复杂度： <ul><li>双指针：O(L)，其中 L 是链表的长度，只需要一次遍历</li><li>两次遍历：O(L)，需要遍历链表两次</li></ul></li><li>空间复杂度：O(1)，只使用常数额外空间</li></ul><hr><h2 id="今日总结" tabindex="-1">今日总结 <a class="header-anchor" href="#今日总结" aria-label="Permalink to &quot;今日总结&quot;">​</a></h2><h3 id="学到了什么" tabindex="-1">学到了什么？ <a class="header-anchor" href="#学到了什么" aria-label="Permalink to &quot;学到了什么？&quot;">​</a></h3><ol><li><strong>快慢指针（Floyd判圈算法）</strong>：检测链表是否有环的经典算法</li><li><strong>双指针技巧</strong>：一次遍历找到倒数第 N 个节点</li><li><strong>虚拟头节点</strong>：简化边界处理，统一操作逻辑</li><li><strong>指针距离控制</strong>：通过控制两个指针的相对距离来定位特定位置</li></ol><h3 id="关键技巧" tabindex="-1">关键技巧 <a class="header-anchor" href="#关键技巧" aria-label="Permalink to &quot;关键技巧&quot;">​</a></h3><table tabindex="0"><thead><tr><th>技巧</th><th>适用场景</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>快慢指针</td><td>检测环、找中点</td><td>O(n)</td><td>O(1)</td></tr><tr><td>双指针（固定距离）</td><td>删除倒数第N个节点</td><td>O(n)</td><td>O(1)</td></tr><tr><td>虚拟头节点</td><td>简化边界处理</td><td>-</td><td>O(1)</td></tr><tr><td>哈希表</td><td>检测重复节点</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><h3 id="快慢指针的应用场景" tabindex="-1">快慢指针的应用场景 <a class="header-anchor" href="#快慢指针的应用场景" aria-label="Permalink to &quot;快慢指针的应用场景&quot;">​</a></h3><ol><li><p><strong>检测环</strong>：</p><ul><li>快指针每次走两步，慢指针每次走一步</li><li>如果有环，快指针会追上慢指针</li></ul></li><li><p><strong>找链表中点</strong>：</p><ul><li>快指针每次走两步，慢指针每次走一步</li><li>当快指针到达末尾时，慢指针指向中点</li></ul></li><li><p><strong>找倒数第N个节点</strong>：</p><ul><li>先让一个指针走N步</li><li>然后两个指针同时移动</li><li>先走的指针到达末尾时，后走的指针指向倒数第N个节点</li></ul></li></ol><h3 id="链表操作要点" tabindex="-1">链表操作要点 <a class="header-anchor" href="#链表操作要点" aria-label="Permalink to &quot;链表操作要点&quot;">​</a></h3><ol><li><p><strong>虚拟头节点的使用</strong>：</p><ul><li>删除头节点时不需要特殊处理</li><li>统一操作逻辑，简化代码</li></ul></li><li><p><strong>指针移动技巧</strong>：</p><ul><li>先走固定步数，再同时移动</li><li>控制两个指针的相对距离</li></ul></li><li><p><strong>边界条件处理</strong>：</p><ul><li>空链表：<code>head == null</code></li><li>单节点：<code>head.next == null</code></li><li>删除头节点：使用虚拟头节点</li></ul></li><li><p><strong>常见错误</strong>：</p><ul><li>忘记处理边界情况</li><li>指针移动步数计算错误</li><li>删除节点后忘记更新指针</li></ul></li></ol><h3 id="相似题目推荐" tabindex="-1">相似题目推荐 <a class="header-anchor" href="#相似题目推荐" aria-label="Permalink to &quot;相似题目推荐&quot;">​</a></h3><ul><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noreferrer">环形链表 II</a> - 找到环的入口节点</li><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/" target="_blank" rel="noreferrer">链表的中间结点</a> - 使用快慢指针找中点</li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" target="_blank" rel="noreferrer">相交链表</a> - 找到两个链表的交点</li><li><a href="https://leetcode.cn/problems/palindrome-linked-list/" target="_blank" rel="noreferrer">回文链表</a> - 判断链表是否为回文</li></ul><h3 id="明日计划" tabindex="-1">明日计划 <a class="header-anchor" href="#明日计划" aria-label="Permalink to &quot;明日计划&quot;">​</a></h3><ul><li>Day 5 哈希表基础</li><li>练习：有效的字母异位词、两数之和（复习）</li></ul>`,68)]))}const g=i(t,[["render",p]]);export{o as __pageData,g as default};
