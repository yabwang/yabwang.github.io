import{_ as a,c as i,o as n,ag as l}from"./chunks/framework.DK1-H3E1.js";const g=JSON.parse('{"title":"Day 17 - 二叉树","description":"","frontmatter":{"order":17},"headers":[],"relativePath":"30-day-algorithm/day17.md","filePath":"30-day-algorithm/day17.md","lastUpdated":1770985760000}'),t={name:"30-day-algorithm/day17.md"};function e(h,s,p,r,k,d){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="day-17-二叉树" tabindex="-1">Day 17 - 二叉树 <a class="header-anchor" href="#day-17-二叉树" aria-label="Permalink to &quot;Day 17 - 二叉树&quot;">​</a></h1><blockquote><p>📅 日期：2026年1月24日<br> 🎯 主题：路径和与直径</p></blockquote><h2 id="今日题目" tabindex="-1">今日题目 <a class="header-anchor" href="#今日题目" aria-label="Permalink to &quot;今日题目&quot;">​</a></h2><h3 id="题目1-路径总和-path-sum" tabindex="-1">题目1：路径总和 (Path Sum) <a class="header-anchor" href="#题目1-路径总和-path-sum" aria-label="Permalink to &quot;题目1：路径总和 (Path Sum)&quot;">​</a></h3><p><strong>难度</strong>：⭐ 简单</p><p><strong>链接</strong>：<a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noreferrer">LeetCode 112. 路径总和</a></p><h4 id="题目描述" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述" aria-label="Permalink to &quot;题目描述&quot;">​</a></h4><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code>。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code>。</p><p>叶子节点 是指没有子节点的节点。</p><p><strong>示例：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：存在路径 5→4→11→2，和为 22。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：root = [1,2,3], targetSum = 5</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：不存在和为 5 的根到叶子路径。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：root = [], targetSum = 0</span></span>
<span class="line"><span>输出：false</span></span></code></pre></div><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h4 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h4><p><strong>方法一：递归（DFS）</strong> ✅ 推荐</p><p>核心思想：</p><ol><li>空节点返回 <code>false</code></li><li>若当前是叶子（左右都为空），判断 <code>root.val == targetSum</code> 返回 true/false</li><li>否则递归左子树或右子树，目标和变为 <code>targetSum - root.val</code></li><li>左右有一边为 true 即存在路径</li></ol><p><strong>关键点</strong>：</p><ul><li>必须在<strong>叶子</strong>处判断，不能在半路和为 targetSum 就返回 true（题目要求根到叶子）</li><li>时间复杂度 O(n)，空间复杂度 O(h)</li></ul><h4 id="代码实现" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Definition for a binary tree node.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * public class TreeNode {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     int val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode() {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode(int val) { this.val = val; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.val = val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.left = left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.right = right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> targetSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 叶子节点：判断剩余和是否等于当前值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> targetSum;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> targetSum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.val;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left, next) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right, next);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h4><ul><li>时间复杂度：O(n)，每个节点至多访问一次</li><li>空间复杂度：O(h)，递归栈深度为树高</li></ul><hr><h3 id="题目2-二叉树的直径-diameter-of-binary-tree" tabindex="-1">题目2：二叉树的直径 (Diameter of Binary Tree) <a class="header-anchor" href="#题目2-二叉树的直径-diameter-of-binary-tree" aria-label="Permalink to &quot;题目2：二叉树的直径 (Diameter of Binary Tree)&quot;">​</a></h3><p><strong>难度</strong>：⭐ 简单</p><p><strong>链接</strong>：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noreferrer">LeetCode 543. 二叉树的直径</a></p><h4 id="题目描述-1" tabindex="-1">题目描述 <a class="header-anchor" href="#题目描述-1" aria-label="Permalink to &quot;题目描述&quot;">​</a></h4><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong>。二叉树的直径是指树中任意两个节点之间最长路径的 <strong>长度</strong>。这条路径可能经过也可能不经过根节点。两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [1,2,3,4,5]</span></span>
<span class="line"><span>输出：3</span></span>
<span class="line"><span>解释：最长的路径是 [4,2,1,3] 或 [5,2,1,3]，长度为 3（边数）。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输入：root = [1,2]</span></span>
<span class="line"><span>输出：1</span></span></code></pre></div><p><strong>提示</strong>：</p><ul><li>树中节点数目在范围 <code>[1, 10^4]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="解题思路-1" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路-1" aria-label="Permalink to &quot;解题思路&quot;">​</a></h4><p><strong>方法一：递归 + 全局最大直径</strong> ✅ 推荐</p><p>核心思想：</p><ol><li>对每个节点，若「直径」经过该节点，则直径 = 左子树高度 + 右子树高度（边数 = 左深度 + 右深度）</li><li>定义递归函数返回「以当前节点为根的树的高度」（边数，即 max(左高, 右高) + 1，叶子为 0）</li><li>在递归过程中，用当前节点的 左高+右高 更新全局最大直径</li><li>最终返回全局最大直径</li></ol><p><strong>关键点</strong>：</p><ul><li>直径是边数，不是节点数；高度也是从当前节点到叶子的边数</li><li>空节点高度 -1 或 0 均可，统一约定：空返回 0，则高度 = 1 + max(左, 右)，直径 = 左高 + 右高（不 +1）</li><li>时间复杂度 O(n)，空间复杂度 O(h)</li></ul><h4 id="代码实现-1" tabindex="-1">代码实现 <a class="header-anchor" href="#代码实现-1" aria-label="Permalink to &quot;代码实现&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Definition for a binary tree node.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * public class TreeNode {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     int val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode() {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode(int val) { this.val = val; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     TreeNode(int val, TreeNode left, TreeNode right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.val = val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.left = left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *         this.right = right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> *     }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxDiameter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> diameterOfBinaryTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxDiameter;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回以 root 为根的树的高度（边数），并顺带更新经过 root 的直径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leftH </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rightH </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 经过当前节点的直径 = 左高 + 右高（边数）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        maxDiameter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(maxDiameter, leftH </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rightH);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(leftH, rightH);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="复杂度分析-1" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析-1" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h4><ul><li>时间复杂度：O(n)，每个节点访问一次</li><li>空间复杂度：O(h)，递归栈</li></ul><hr><h2 id="今日总结" tabindex="-1">今日总结 <a class="header-anchor" href="#今日总结" aria-label="Permalink to &quot;今日总结&quot;">​</a></h2><h3 id="学到了什么" tabindex="-1">学到了什么？ <a class="header-anchor" href="#学到了什么" aria-label="Permalink to &quot;学到了什么？&quot;">​</a></h3><ol><li><strong>路径总和</strong>：根到叶子路径，递归时在叶子处判断 <code>targetSum == root.val</code>，非叶子则用 <code>targetSum - root.val</code> 递归左右</li><li><strong>二叉树的直径</strong>：任意两节点最长路径（边数），可转化为「经过某节点的最长路径 = 左高 + 右高」，递归求高度的同时更新全局最大直径</li><li><strong>边数 vs 节点数</strong>：直径、高度按边数计算时，空节点高度 0，非空高度 = 1 + max(左, 右)</li><li><strong>全局变量/引用</strong>：在递归中需要「收集所有节点上的某种最值」时，用成员变量或单元素数组在递归中更新</li></ol><h3 id="关键技巧" tabindex="-1">关键技巧 <a class="header-anchor" href="#关键技巧" aria-label="Permalink to &quot;关键技巧&quot;">​</a></h3><table tabindex="0"><thead><tr><th>技巧</th><th>适用场景</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>DFS 路径和</td><td>根到叶子路径判断</td><td>O(n)</td><td>O(h)</td></tr><tr><td>递归求高 + 更新</td><td>直径、最大路径和等</td><td>O(n)</td><td>O(h)</td></tr><tr><td>叶子才判结果</td><td>路径必须到叶子</td><td>-</td><td>-</td></tr></tbody></table><h3 id="路径与直径要点" tabindex="-1">路径与直径要点 <a class="header-anchor" href="#路径与直径要点" aria-label="Permalink to &quot;路径与直径要点&quot;">​</a></h3><ol><li><strong>路径总和</strong>：必须到叶子再判断；中途 sum 相等不能算（除非题目说明可为任意节点）</li><li><strong>直径</strong>：不要求过根；对每个节点算「左高+右高」取 max 即可</li><li><strong>常见错误</strong>：路径总和在非叶子返回 true；直径用节点数而非边数；忘记用全局或引用保存最大直径</li></ol><h3 id="相似题目推荐" tabindex="-1">相似题目推荐 <a class="header-anchor" href="#相似题目推荐" aria-label="Permalink to &quot;相似题目推荐&quot;">​</a></h3><ul><li><a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noreferrer">路径总和 II</a> - 输出所有满足条件的路径</li><li><a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noreferrer">路径总和 III</a> - 路径不必从根开始</li><li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noreferrer">二叉树的最大路径和</a> - 路径和的最大值（含负值）</li><li><a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noreferrer">合并二叉树</a> - 递归合并两棵树</li></ul><h3 id="明日计划" tabindex="-1">明日计划 <a class="header-anchor" href="#明日计划" aria-label="Permalink to &quot;明日计划&quot;">​</a></h3><ul><li>Day 18 二叉搜索树</li><li>练习：BST 性质、验证 BST、BST 搜索/插入、中序后继等</li></ul>`,55)]))}const c=a(t,[["render",e]]);export{g as __pageData,c as default};
