import{_ as a,c as l,o as n,ag as r}from"./chunks/framework.DK1-H3E1.js";const g=JSON.parse('{"title":"JVM 知识总结","description":"","frontmatter":{"order":10},"headers":[],"relativePath":"interview/jvm-basics.md","filePath":"interview/jvm-basics.md","lastUpdated":1770821404000}'),s={name:"interview/jvm-basics.md"};function o(e,t,i,d,h,c){return n(),l("div",null,t[0]||(t[0]=[r(`<h1 id="jvm-知识总结" tabindex="-1">JVM 知识总结 <a class="header-anchor" href="#jvm-知识总结" aria-label="Permalink to &quot;JVM 知识总结&quot;">​</a></h1><h2 id="目录" tabindex="-1">目录 <a class="header-anchor" href="#目录" aria-label="Permalink to &quot;目录&quot;">​</a></h2><ul><li><a href="#1-内存模型">1. 内存模型</a></li><li><a href="#2-垃圾回收">2. 垃圾回收</a></li><li><a href="#3-类加载机制">3. 类加载机制</a></li><li><a href="#4-性能调优与监控">4. 性能调优与监控</a></li></ul><hr><h2 id="_1-内存模型" tabindex="-1">1. 内存模型 <a class="header-anchor" href="#_1-内存模型" aria-label="Permalink to &quot;1. 内存模型&quot;">​</a></h2><h3 id="_1-1-运行时数据区-jdk-8" tabindex="-1">1.1 运行时数据区（JDK 8） <a class="header-anchor" href="#_1-1-运行时数据区-jdk-8" aria-label="Permalink to &quot;1.1 运行时数据区（JDK 8）&quot;">​</a></h3><table tabindex="0"><thead><tr><th>区域</th><th>线程是否共享</th><th>作用</th></tr></thead><tbody><tr><td><strong>程序计数器</strong></td><td>私有</td><td>当前线程执行的字节码行号指示器；Native 方法时为空</td></tr><tr><td><strong>Java 虚拟机栈</strong></td><td>私有</td><td>存储栈帧：局部变量表、操作数栈、动态链接、方法出口；栈深度超限 → StackOverflowError</td></tr><tr><td><strong>本地方法栈</strong></td><td>私有</td><td>为 Native 方法服务</td></tr><tr><td><strong>堆</strong></td><td>共享</td><td>存放对象实例、数组；无法扩展 → OutOfMemoryError</td></tr><tr><td><strong>方法区</strong></td><td>共享</td><td>类元信息、常量、静态变量、JIT 编译后的代码；JDK 8 用元空间 MetaSpace 实现，使用本地内存</td></tr></tbody></table><p><strong>要点</strong>：</p><ul><li>堆、方法区为线程共享；程序计数器、虚拟机栈、本地方法栈为线程私有。</li><li>直接内存（Direct Memory）不属于运行时数据区，但 OOM 时也可能抛出 OutOfMemoryError。</li></ul><h3 id="_1-2-堆内存分区" tabindex="-1">1.2 堆内存分区 <a class="header-anchor" href="#_1-2-堆内存分区" aria-label="Permalink to &quot;1.2 堆内存分区&quot;">​</a></h3><ul><li><strong>新生代（Young Generation）</strong><ul><li><strong>Eden</strong>：新对象优先分配在这里。</li><li><strong>Survivor</strong>：两个 Survivor（From / To），复制算法时用于保留存活对象，默认比例 Eden : From : To ≈ 8 : 1 : 1。</li></ul></li><li><strong>老年代（Old Generation）</strong><ul><li>存活多次 GC 的对象晋升到老年代；大对象（超过阈值）可能直接进入老年代。</li></ul></li></ul><p><strong>对象创建简要过程</strong>：</p><ol><li>类加载检查 → 2. 分配内存（指针碰撞 / 空闲列表）→ 3. 初始化零值 → 4. 设置对象头 → 5. 执行 <code>&lt;init&gt;</code>。</li></ol><p><strong>对象内存布局</strong>：</p><ul><li>对象头：Mark Word（哈希、GC 年龄、锁信息等）、类型指针。</li><li>实例数据：字段。</li><li>对齐填充：8 字节对齐。</li></ul><h3 id="_1-3-方法区与元空间-jdk-8" tabindex="-1">1.3 方法区与元空间（JDK 8） <a class="header-anchor" href="#_1-3-方法区与元空间-jdk-8" aria-label="Permalink to &quot;1.3 方法区与元空间（JDK 8）&quot;">​</a></h3><ul><li><strong>JDK 7</strong>：方法区在堆中，用永久代（PermGen）实现。</li><li><strong>JDK 8</strong>：永久代移除，用 <strong>元空间（Metaspace）</strong> 在本地内存实现，存类元信息等，不再占用堆，避免 PermGen OOM，仅受本地内存限制。</li></ul><p><strong>面试重点</strong>：</p><ul><li>堆存对象实例；栈存局部变量和栈帧；方法区/元空间存类信息与常量。</li><li>为什么要有两个 Survivor：复制算法需要一块“保留区”，两个 Survivor 轮换，避免内存碎片，适合新生代大量“朝生夕死”的对象。</li></ul><hr><h2 id="_2-垃圾回收" tabindex="-1">2. 垃圾回收 <a class="header-anchor" href="#_2-垃圾回收" aria-label="Permalink to &quot;2. 垃圾回收&quot;">​</a></h2><h3 id="_2-1-如何判定对象可回收" tabindex="-1">2.1 如何判定对象可回收 <a class="header-anchor" href="#_2-1-如何判定对象可回收" aria-label="Permalink to &quot;2.1 如何判定对象可回收&quot;">​</a></h3><ul><li><strong>引用计数</strong>：有循环引用问题，Java 未采用。</li><li><strong>可达性分析</strong>：从 GC Roots 出发，不可达则视为可回收。 <ul><li>GC Roots：栈中引用、静态变量、常量、JNI 引用等。</li></ul></li><li><strong>引用类型</strong>：强引用、软引用、弱引用、虚引用；只有强引用会阻止回收。</li></ul><h3 id="_2-2-垃圾回收算法" tabindex="-1">2.2 垃圾回收算法 <a class="header-anchor" href="#_2-2-垃圾回收算法" aria-label="Permalink to &quot;2.2 垃圾回收算法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>算法</th><th>思路</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>标记-清除</td><td>标记可回收，再统一清除</td><td>实现简单</td><td>产生碎片</td></tr><tr><td>标记-复制</td><td>存活对象复制到另一块区域</td><td>无碎片、高效</td><td>空间折半</td></tr><tr><td>标记-整理</td><td>标记后存活对象向一端移动</td><td>无碎片、连续</td><td>移动有开销</td></tr></tbody></table><ul><li><strong>新生代</strong>：多采用标记-复制（对象存活率低）。</li><li><strong>老年代</strong>：多采用标记-清除或标记-整理（对象存活率高，复制成本大）。</li></ul><h3 id="_2-3-常见垃圾回收器" tabindex="-1">2.3 常见垃圾回收器 <a class="header-anchor" href="#_2-3-常见垃圾回收器" aria-label="Permalink to &quot;2.3 常见垃圾回收器&quot;">​</a></h3><table tabindex="0"><thead><tr><th>回收器</th><th>区域</th><th>特点</th></tr></thead><tbody><tr><td>Serial</td><td>新生代</td><td>单线程，STW，适合单核/小堆</td></tr><tr><td>ParNew</td><td>新生代</td><td>多线程版 Serial，常与 CMS 搭配</td></tr><tr><td>Parallel Scavenge</td><td>新生代</td><td>多线程，关注吞吐量</td></tr><tr><td>Serial Old</td><td>老年代</td><td>单线程，标记-整理</td></tr><tr><td>Parallel Old</td><td>老年代</td><td>多线程，与 Parallel Scavenge 搭配</td></tr><tr><td>CMS</td><td>老年代</td><td>并发标记清除，低停顿，有碎片、并发阶段占用 CPU</td></tr><tr><td>G1</td><td>全堆</td><td>分区（Region），可预测停顿，兼顾吞吐与低延迟</td></tr><tr><td>ZGC / Shenandoah</td><td>全堆</td><td>超低延迟，适合大堆</td></tr></tbody></table><p><strong>面试重点</strong>：</p><ul><li>CMS：并发收集，减少 STW；缺点为碎片、并发阶段 CPU 敏感、可能产生浮动垃圾。</li><li>G1：将堆划分为多个 Region，优先回收价值高（回收收益大）的 Region，适合大堆和停顿时间敏感场景。</li></ul><h3 id="_2-4-minor-gc、major-gc、full-gc" tabindex="-1">2.4 Minor GC、Major GC、Full GC <a class="header-anchor" href="#_2-4-minor-gc、major-gc、full-gc" aria-label="Permalink to &quot;2.4 Minor GC、Major GC、Full GC&quot;">​</a></h3><ul><li><strong>Minor GC</strong>：新生代 GC，较频繁，速度较快。</li><li><strong>Major GC</strong>：通常指老年代 GC（有时与 Full GC 混用）。</li><li><strong>Full GC</strong>：整堆 + 方法区/元空间回收，STW 最长，应尽量减少发生。</li></ul><hr><h2 id="_3-类加载机制" tabindex="-1">3. 类加载机制 <a class="header-anchor" href="#_3-类加载机制" aria-label="Permalink to &quot;3. 类加载机制&quot;">​</a></h2><h3 id="_3-1-类加载过程" tabindex="-1">3.1 类加载过程 <a class="header-anchor" href="#_3-1-类加载过程" aria-label="Permalink to &quot;3.1 类加载过程&quot;">​</a></h3><ol><li><strong>加载（Loading）</strong><br> 将 class 文件读入内存，生成 <code>Class</code> 对象。</li><li><strong>链接（Linking）</strong><ul><li><strong>验证</strong>：格式、字节码、符号引用等。</li><li><strong>准备</strong>：为类静态变量分配内存并设零值；<code>static final</code> 常量在准备阶段即可赋字面量。</li><li><strong>解析</strong>：将常量池中的符号引用替换为直接引用。</li></ul></li><li><strong>初始化（Initialization）</strong><br> 执行 <code>&lt;clinit&gt;</code>，为静态变量赋真实初值并执行静态块。</li></ol><p><strong>面试重点</strong>：</p><ul><li>准备阶段只做默认零值，不执行赋值语句；初始化阶段才执行静态赋值和 static 块。</li><li>触发初始化的典型场景：new、反射、调用静态方法/静态字段（非常量）、子类初始化时先触发父类初始化、主类等。</li></ul><h3 id="_3-2-双亲委派模型" tabindex="-1">3.2 双亲委派模型 <a class="header-anchor" href="#_3-2-双亲委派模型" aria-label="Permalink to &quot;3.2 双亲委派模型&quot;">​</a></h3><ul><li><strong>定义</strong>：类加载请求先交给父加载器；父加载器无法加载时，子加载器才尝试加载。</li><li><strong>层次</strong>：Bootstrap → Extension → Application（系统类加载器）→ 自定义类加载器。</li><li><strong>作用</strong>：避免类被重复加载；保护核心类库不被应用层同名类替换（如自定义 <code>java.lang.String</code> 不会被加载）。</li></ul><p><strong>破坏双亲委派</strong>：</p><ul><li>如 JDK 1.2 引入双亲委派前已有类加载器未遵循；SPI（如 JDBC）中 Bootstrap 需加载厂商实现，通过线程上下文类加载器（Context ClassLoader）加载。</li><li>热部署、OSGi 等场景会按模块使用不同类加载器，也会打破“单一委派”的约束。</li></ul><h3 id="_3-3-自定义类加载器" tabindex="-1">3.3 自定义类加载器 <a class="header-anchor" href="#_3-3-自定义类加载器" aria-label="Permalink to &quot;3.3 自定义类加载器&quot;">​</a></h3><ul><li>继承 <code>ClassLoader</code>，重写 <code>findClass()</code>（建议），在内部调用 <code>defineClass()</code> 将字节数组转为 <code>Class</code>。</li><li>一般不重写 <code>loadClass()</code>，否则会破坏双亲委派；重写 <code>findClass()</code> 可在保持委派的前提下自定义“从哪里读 class”。</li></ul><p><strong>面试重点</strong>：</p><ul><li>同一类由同一加载器加载时，才认为“相等”（equals）；不同加载器加载的同一 class 文件会得到不同类。</li></ul><hr><h2 id="_4-性能调优与监控" tabindex="-1">4. 性能调优与监控 <a class="header-anchor" href="#_4-性能调优与监控" aria-label="Permalink to &quot;4. 性能调优与监控&quot;">​</a></h2><h3 id="_4-1-常用-jvm-参数-示例" tabindex="-1">4.1 常用 JVM 参数（示例） <a class="header-anchor" href="#_4-1-常用-jvm-参数-示例" aria-label="Permalink to &quot;4.1 常用 JVM 参数（示例）&quot;">​</a></h3><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 堆</span></span>
<span class="line"><span>-Xms512m                    # 初始堆</span></span>
<span class="line"><span>-Xmx512m                    # 最大堆（建议与 -Xms 相同，避免动态扩展）</span></span>
<span class="line"><span>-Xmn256m                    # 新生代（老年代 = 堆 - 新生代）</span></span>
<span class="line"><span>-XX:SurvivorRatio=8         # Eden : Survivor = 8 : 1 : 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 元空间（JDK 8）</span></span>
<span class="line"><span>-XX:MetaspaceSize=128m</span></span>
<span class="line"><span>-XX:MaxMetaspaceSize=256m</span></span>
<span class="line"><span></span></span>
<span class="line"><span># GC 选择</span></span>
<span class="line"><span>-XX:+UseG1GC                # 使用 G1</span></span>
<span class="line"><span>-XX:MaxGCPauseMillis=200    # 期望最大停顿（G1 等）</span></span>
<span class="line"><span></span></span>
<span class="line"><span># GC 日志（JDK 8）</span></span>
<span class="line"><span>-XX:+PrintGCDetails</span></span>
<span class="line"><span>-XX:+PrintGCDateStamps</span></span>
<span class="line"><span>-Xloggc:gc.log</span></span>
<span class="line"><span></span></span>
<span class="line"><span># GC 日志（JDK 9+）</span></span>
<span class="line"><span>-Xlog:gc*:file=gc.log:time,level,tags</span></span></code></pre></div><h3 id="_4-2-内存泄漏排查思路" tabindex="-1">4.2 内存泄漏排查思路 <a class="header-anchor" href="#_4-2-内存泄漏排查思路" aria-label="Permalink to &quot;4.2 内存泄漏排查思路&quot;">​</a></h3><ul><li><strong>现象</strong>：堆持续增长、Full GC 频繁但回收不多、最终 OOM。</li><li><strong>步骤</strong>： <ol><li>使用 <code>jmap -heap &lt;pid&gt;</code> 看堆概况；<code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code> 导出堆快照。</li><li>用 MAT、JProfiler 等分析：查看支配树、大对象、重复/异常集合（如未关闭的集合不断加入对象）。</li><li>结合业务：未关闭的连接、监听器未移除、静态集合无限增长、ThreadLocal 未 remove 等。</li></ol></li></ul><h3 id="_4-3-gc-日志简要解读" tabindex="-1">4.3 GC 日志简要解读 <a class="header-anchor" href="#_4-3-gc-日志简要解读" aria-label="Permalink to &quot;4.3 GC 日志简要解读&quot;">​</a></h3><ul><li>关注：Young GC / Full GC 频率、每次停顿时间、回收前后各区域容量变化。</li><li>若 Young GC 频繁且回收少：可能是新生代过小或短生命周期对象过多。</li><li>若 Full GC 频繁且老年代居高不下：可能存在老年代堆积或泄漏。</li></ul><h3 id="_4-4-常用监控与诊断工具" tabindex="-1">4.4 常用监控与诊断工具 <a class="header-anchor" href="#_4-4-常用监控与诊断工具" aria-label="Permalink to &quot;4.4 常用监控与诊断工具&quot;">​</a></h3><table tabindex="0"><thead><tr><th>工具/命令</th><th>作用</th></tr></thead><tbody><tr><td><strong>jps</strong></td><td>列出 Java 进程</td></tr><tr><td><strong>jstat</strong></td><td>查看 GC、类加载、编译等统计（如 <code>jstat -gc &lt;pid&gt; 1000</code>）</td></tr><tr><td><strong>jmap</strong></td><td>堆信息、堆转储（<code>-heap</code>、<code>-dump</code>）</td></tr><tr><td><strong>jstack</strong></td><td>线程快照，查死锁、阻塞（<code>jstack &lt;pid&gt;</code>）</td></tr><tr><td><strong>jinfo</strong></td><td>查看/修改 JVM 参数</td></tr><tr><td><strong>VisualVM</strong></td><td>图形化监控堆、线程、CPU、GC</td></tr><tr><td><strong>Arthas</strong></td><td>在线诊断：反编译、查看堆栈、监控方法调用、追踪等</td></tr></tbody></table><p><strong>面试重点</strong>：</p><ul><li>线上 CPU 飙高：先用 <code>top</code> 定位进程和线程，再用 <code>jstack</code> 看该线程栈，结合代码定位。</li><li>OOM：堆转储 + MAT 分析，看哪些对象占用量大、是否合理、是否有泄漏路径。</li></ul><hr><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><ul><li><strong>内存</strong>：堆（对象）、栈（栈帧）、方法区/元空间（类元信息）；堆分新生代与老年代，新生代常用复制算法。</li><li><strong>GC</strong>：可达性分析判活；算法有标记-清除、标记-复制、标记-整理；回收器按场景选 Serial、CMS、G1、ZGC 等。</li><li><strong>类加载</strong>：加载 → 链接（验证、准备、解析）→ 初始化；双亲委派保证核心类安全；自定义类加载器一般重写 <code>findClass()</code>。</li><li><strong>调优与排查</strong>：合理设置堆与 GC 参数；结合 jstat、jmap、jstack、堆转储与 MAT/Arthas 做内存与 CPU 问题定位。</li></ul>`,61)]))}const u=a(s,[["render",o]]);export{g as __pageData,u as default};
